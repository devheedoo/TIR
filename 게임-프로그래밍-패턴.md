

게임 프로그래밍 패턴

- 추상화와 디커플링을 잘 활용하면 좋지만, 유연함이 필요하다는 확신이 있을 때만
- 성능 최적화는 기획이 완료되었을 때
- 버릴 코드에 시간 낭비하지 않기



명령 패턴

- 함수 호출을 객체로 감싸 메서드로 만드는 것
- 입력 키 변경하기
- 캐릭터 이동 취소하기



경량 패턴

- 숲 렌더링하기



관찰자 패턴

- 업적 업데이트하기
- 관찰자 중 하나라도 느리면 대상이 블록될 수도 있다 (UI가 멈출 수 있다)
- 관찰자를 멀티스레드, 락과 함께 사용할 때는 정말 조심해야 한다
- 관찰자 제거에 주의해야 한다
- 사라진 리스너 문제(lapsed listener problem)
- 명령 실행 과정을 동적으로 추론해야 한다
- 서로 연관 없는 코드들이 상호 작용하기에 좋고, 하나의 기능을 구현하기 위핸 코드 덩어리 안에서는 유용하지 않다



프로토타입 패턴

- 프로로타입의 클래스뿐만 아니라 상태도 같이 복제한다
- 빠른 유령, 약한 유령, 느린 유령용 스포너를 쉽게 만들 수 있다



싱글턴 패턴

- 인스턴스를 하나만 생성하고, 전역에서 접근할 수 있다
- 장점
  - 한 번도 사용하지 않으면 인스턴스를 생성하지 않는다
  - 런타임에 초기화된다 (다른 정보가 생성된 후에 게으른 초기화)
  - 싱글턴을 상속할 수 있다
- 단점
  - 코드가 흩어져 이해하기 어렵다
  - 커플링을 조장한다
  - 멀티스레딩에 어우리지 않는다
  - 게으른 초기화 시점을 정밀하게 처리해줘야 한다
- 대안
  - 클래스가 꼭 필요한가?
  - 런타임에 인스턴스 한 개만 갖도록 보장하기
  - 인스턴스에 쉽게 접근하기
    - 넘겨주기
    - 상위 클래스로부터 얻기
    - 이미 전역인 객체로부터 얻기
    - 서비스 중개자로부터 얻기

